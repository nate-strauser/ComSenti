'''Externally defined basic sentiments for algorithm operations'''import logging as logimport adjectives as adjimport osfrom google.appengine.api import memcache from models import *def register(SENTIMENTS):    SENTIMENTS['+'] = sentiment_positive_token    SENTIMENTS['-'] = sentiment_negative_token    SENTIMENTS['*'] = sentiment_overall_tokenclass sentiment_positive_token(object):    modtext = ""        def nud(self):        return 0    def led(self, text, company):        dictionary = memcache.get('ADJECTIVES')                if dictionary is None:            log.info('Load the cache with adjectives.')            #extract dictionary from the database            #and save it in cache as a dictionary object            dictionary = {}            adjectives = Word.all()                        for adjective in adjectives:                dictionary[adjective.word] = int(adjective.value)            #cache expiration is set to 1 hour                memcache.set('ADJECTIVES', dictionary, 60*60)            log.info('Loaded %d adjectives in the dictionary.', len(dictionary))                     #analyze text to get rating value        log.debug("Executing analyzer")        try:                        #Analyzer currently looks for:            #1. Looks for words in the text and compare with the dictionary            #2. Look for negation and reverse the rating            #3. Look if the word is uppercase and increase the sentiment                        value = 0            newtext = ''            words = text.lower().split()            p_words = text.split()            index = -1            for word in words:                index += 1                val = 0                #look for each word in the text if exists in the dictionary                if dictionary.has_key(word):                    log.debug("Found word in dictionary %s of %s", word, dictionary.get(word, 0))                    val = dictionary.get(word, 0)                                        #adjust the value of the sentiment in case                    # 1. Negation is found in front                    log.debug("Look for negation")                    if index > 1:                        if words[index-1] == 'not' or words[index-1] == 'no':                            val = val * -1                            log.debug("Negation found: %s", word)                    # 2. Word is uppercase, increase the sentiment by 30%                    log.debug("Look for uppercase")                    if p_words[index] == word.upper():                        val = val + 0.3 * val                        log.debug("Uppercase found: %s", word)                                        value = value + int(val)                                        #insert special characters around the adjectives to exclude from search                    #also to special format in the UI                    goodword = '['+word+']'+'('+str(val)+')'                    badword = '{'+word+'}'+'('+str(val)+')'                                    if val > 0:                   newtext = newtext + ' ' + goodword                elif val < 0:                   newtext = newtext + ' ' + badword                else:                   newtext = newtext + ' ' + word                            log.debug("Analyzer found a sentiment value of [%s]", value)                        #verify against max and min            if value > 20:                value = 20            elif value < -20:                value = -20            log.debug("After comparing against Maxim, Minim: [%s]", value)            self.modtext = newtext            return value                except Exception, e:            log.error("Error in the counter ", e)            return 0class sentiment_negative_token(object):    def nud(self):        0    def led(self, text, company):        returnclass sentiment_overall_token(object):    def nud(self):        0    def led(self, text, company):        return